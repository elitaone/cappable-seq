#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
# author Bo Yan

'''
# Logs:

Created on Sept 3, 2018

Modified on Oct 3, 2018: 
    change the re in FindMost(ls), add TPM cutoff 
Modified on Jan 22, 2019: 
    change all the re.findall to syntax e.g. re.findall('nio=(\d.*?);', word)[0]; 
Modified on Jan 22, 2019: :
    add ';' to the entry on the chr having only one peak in the cluster, e.g. chrM    2434    +       2434;
Modified on Mar 5, 2019: 
    change the cutoff using TPM_total to using TPM_summit
'''

'''
Based on python 2.7

This is used cluster the nearby TSS sites.
Can not be used by multiple threads in parallel.

Usage:
$python ClusterTssGTF.py --input .tsscount.gtf --output output.gtf --distance int --cutoff float

Logic:
Cluster the nearby TSSs [start at T1, T2 ..Tn] if abs(T2-T1)<distance cutoff ... abs(Tn -Tn-1)<distance cutoff;
in other words, the distance between TSSs in the Cluster <distance cutoff;
report the TSS cluster as well as the summit of the cluster.

--input: a gtf (1-coordination) file having the TSS and TPM information, which is generated by CountTssTag.py or FilterTSS.py:

Examples:

(1).tss.gtf generated by CountTssTagGTF.py:
    chr, source, feature, tss, tss, TPM, strand, coordination, attribute
    chr16	D3D4.gtf	tssgtf	53704156	53704156	1.61137440758	+	1-coordination	nio=102;TPM=1.61137440758;

(2).tsscount.gtf generated by FilterTssGTF.py:
    chr, source, feature, tss, tss, TPM, strand, coordination, attribute (combined bed-3-4-column) 
    chr16	D3D4.gtf	tssgtf	53704156	53704156	1.61137440758	+	1-coordination	nio=102;TPM=1.61137440758;nioMAPQ=102;Ratio=0.69;nio_control=148;TPM_control=2.33807266983;

--output: a gtf file having the TSS cluster start and end, TPM information and cluster summit, 1-coordination.
    e.g.
    chr, source, feature, 5'end of TSS cluster, 3'end of TSS cluster, TPM of cluster, strand, coordination, attribute (nio of cluster; TPM of cluster; summit; nio_summit; TPM_summit)
    chr16	D3D4.gtf	cluster	53704156	53704176	4.34439178515	+	1-coordination	nio=275;TPM=4.34439178515;summit=53704176;nio_summit=173;TPM_summit=2.73301737757; 
    
    Also automatcially generate another file TSScluster.report having the original TSS sites in each cluster.

--cutoff: float, default=0
    a float used to filter the clusters/singleton(if no nearby TSS) whose TPM_summit are below the defined cutoff;
    in other words, all the TSS in the cluster having TPM<cutoff.

--distance: int, default=5
    The distance used to define adjacent TSSs, whose distance<=int will be clustered.

Note:
(1) This script could be used for input file having multiple chrs.
(2) The output gtf is sorted based on the chr and start (sort -f -k1,1 -k4,4n).
(3) If any chr only has one TSS position, then report this one in the output.
(4) If there are more than one TSS in the cluster having the maximum number of TPM, report the smallest TSS as summit, e.g. using 158 for (158,161) cluster.
(5) Here nio/TPM is the total number/TPM of tags from all the TSSs in the cluster, and this is compatable with the caculateRawReadsTSS_v3.py calculation.
(6) Only extract the nio and TPM for each entry, will ignore the other information in the attribute column in input (e.g.Ratio, nioMAPQ);
    e.g. the input file could have the nioMAPQ/Ratio information, but this information is not used or output in the cluster analysis.
(7) Also automatcially generate another file TSScluster.report (1-coordination) having the original TSS sites in each cluster, e.g.:
    chr, summit of cluster, strand, TSS in the cluster
    chr16	53704176	+	53704156;53704176;
'''

try: 
    from collections import deque
    from subprocess import check_call, check_output
    import os
    import argparse
    import re
except:
    print "Import module error."
    quit()
    
##-------functions

def FindMost(ls):
    '''
    From a list containing adjacent TSSs,
    return the summit, the boundary of TSS peak (the most 5' and 3'end TSS), 
    and the total number of reads in the list

    e.g. chr, start, end, nio, TPM, strand
    ['NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     143     143     2.66445339405   +       1-coordination  nio=2;TPM=2.66445339405;Ratio=0.54574933089;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     147     147     6.66113348512   +       1-coordination  nio=5;TPM=6.66113348512;Ratio=1.36437332722;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     148     148     147.87716337    +       1-coordination  nio=111;TPM=147.87716337;Ratio=15.1445439322;nio_control=2;TPM_control=9.76438538076;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     150     150     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     151     151     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     158     158     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     161     161     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;']
    
    return a list:
    chr, source, feature, 5'end of TSS cluster, 3'end of TSS cluster, total TPM of all the TSS in the cluster, strand, coordination, attribute
    ['NC_000913.3', 'M9.enrich_contronl.ratio.tss', 'cluster', '143', '161', '162.531657037', '+', '1-coordination', 'nio=122;TPM=162.531657037;summit=148;nio_summit=111;TPM_summit=147.87716337;']
    '''
    summit=ls[0]
    nio_total=0
    TPM_total=0
    TSS_ls=[]

    for item in ls:
        TSS_ls.append(int(item.split()[3]))
        if float(re.findall('TPM=(\d.*?);', item)[0]) > float(re.findall('TPM=(\d.*?);', summit)[0]):
            summit=item
        nio_total += int(re.findall('nio=(\d.*?);', item)[0])
        TPM_total += float(re.findall('TPM=(\d.*?);', item)[0])
    
    temp = summit.split('\t')
    temp[-1] = ';'.join(['nio='+str(nio_total), 'TPM='+str(TPM_total), 'summit='+temp[3], 'nio_summit='+re.findall('nio=(\d.*?);', summit)[0], 'TPM_summit='+temp[5],''])
    temp[2] = 'cluster'
    temp[3] = str(min(TSS_ls))
    temp[4] = str(max(TSS_ls))
    temp[5] = str(TPM_total)
    return temp


def Report(ls):
    '''
    From a list containing adjacent TSSs,
    return all the original TSSs in a list.
    ls e.g.: 
    chr, start, end, nio, TPM, strand
    ['NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     143     143     2.66445339405   +       1-coordination  nio=2;TPM=2.66445339405;Ratio=0.54574933089;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     147     147     6.66113348512   +       1-coordination  nio=5;TPM=6.66113348512;Ratio=1.36437332722;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     148     148     147.87716337    +       1-coordination  nio=111;TPM=147.87716337;Ratio=15.1445439322;nio_control=2;TPM_control=9.76438538076;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     150     150     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     151     151     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     158     158     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;',
    'NC_000913.3     M9.enrich_contronl.ratio.tss    TSS     161     161     1.33222669702   +       1-coordination  nio=1;TPM=1.33222669702;Ratio=0.272874665444;nio_control=0;TPM_control=4.88219269038;']
    
    return '143;147;148;150;151;'
    '''
    temp = [item.split()[3] for item in ls]
    temp.append('')
    return ';'.join(temp)


def cluster_TSS(input_file, output_file, distance, cutoff):
    '''
    cluster the adjacent TSSs on the same chr.
    '''
    print "=================="
    print "Cluster the adjacent TSSs within the distance %d." % distance
    print "Input file is {}.".format(input_file)
    
    with open(input_file) as f:
        chr_list = [] # chr list
        for line in f:
            if line.strip().split('\t')[0] not in chr_list:
                chr_list.append(line.strip().split('\t')[0])
    
    if os.path.dirname(output_file): # e.g. --output /mnt/home/ettwiller/yan/Tzertzinis/170927_nextseq/TSS/D3D4.TPM1.tsscount.gtf
        dir_output = os.path.dirname(output_file)
        if dir_output == '.': # e.g. --output ./D3D4.TPM1.tsscount.gtf
            dir_output = os.getcwd()
    else: # e.g. --output D3D4.TPM1.tsscount.gtf
        dir_output = os.getcwd()
                
    output = open('cluster.temp','w')
    output_report = open('cluster.report.temp','w')
    count_filter = 0 # number of entry (read) filtered
    
    # To run faster, could use awk split based on the first column as used in CountTssGTF.py
    for chr in chr_list:
        #print chr
        command = 'awk -v OFS=\'\\t\' \'{if($1==\"' + chr + '\" && $7==\"+\"){print $0}}\' ' + input_file + '| sort -k4,4n > cluster.positive'
        check_call(command, shell=True)
    
        command = 'awk -v OFS=\'\\t\' \'{if($1==\"' + chr + '\" && $7==\"-\"){print $0}}\' ' + input_file + '| sort -k4,4n > cluster.negative'
        check_call(command, shell=True)
    
        ls = ['cluster.positive', 'cluster.negative']
        for file in ls:
            command = 'wc -l ' + file
            count = int(check_output(command, shell=True).split()[0]) # number of entries
            
            if count==0:
                pass
            elif count==1: # only one TSS on the chr
                with open(file) as f:
                    line = f.readline().strip().split('\t')
                    nio_total = re.findall('nio=(\d.*?);', line[-1])[0]
                    TPM_total = re.findall('TPM=(\d.*?);', line[-1])[0]
                    
                    if float(TPM_total) >= cutoff:
                        line[2] = 'cluster'
                        line[-1] = ';'.join(['nio='+nio_total, 'TPM='+TPM_total, 'summit='+line[3], 'nio_summit='+nio_total, 'TPM_summit='+TPM_total, ''])
                        print>>output, '\t'.join(line)
                        report = [line[0], line[3], line[6], ';'.join([line[3],''])] # [chr, cluster summit, strand,all TSSs in the cluster]
                        print>>output_report, '\t'.join(report)
                    else:
                        count_filter += 1
                    
            else:
                with open(file) as f:
                    q = deque(maxlen=2)
                    line = f.readline()
                    q.append(line.strip()) 
                    temp = [] 
                    temp.append(q[0]) 
   
                    for line in f:
                        q.append(line.strip())
                        if int(q[1].split()[3]) - int(q[0].split()[3]) <=distance: 
                            temp.append(q[1])
                        else:
                            summit = FindMost(temp)
                            # ['NC_000913.3', 'M9.enrich_contronl.ratio.tss', 'cluster', '143', '161', '162.531657037', '+', '1-coordination', 'nio=122;TPM=162.531657037;summit=148;nio_summit=111;TPM_summit=147.87716337;']
                            if float(re.findall('TPM_summit=(\d.*?);', summit[-1])[0]) >= cutoff: # TPM_summit
                                print>>output, '\t'.join(summit)
                                report = [summit[0], re.findall('summit=(\d.*?);',summit[-1])[0], summit[6], Report(temp)] # [chr, cluster summit, strand, all TSSs in the cluster]
                                print>>output_report, '\t'.join(report)
                            else:
                                for item in temp:
                                    count_filter += 1
                           
                            temp = []
                            temp.append(q[1])
                            
                    summit = FindMost(temp) 
                    if float(re.findall('TPM_summit=(\d.*?);', summit[-1])[0]) >= cutoff: 
                        print>>output, '\t'.join(summit)
                        report = [summit[0], re.findall('summit=(\d.*?);',summit[-1])[0], summit[6], Report(temp)] # [chr, cluster summit, strand, all TSSs in the cluster]
                        print>>output_report, '\t'.join(report)
                    else:
                        for item in temp:
                            count_filter += 1
                            
            os.remove(file)

    output.close()
    output_report.close()
    
    command = 'wc -l cluster.temp'
    display = check_output(command, shell=True).split()[0]
    
    # here use -f to ignore case, otherwise KI/GL is before chr1
    command = 'sort -f -k1,1 -k4,4n cluster.temp >' + output_file
    check_call(command, shell=True)
    os.remove('cluster.temp')
    
    command = 'sort -f -k1,1 -k4,4n cluster.report.temp > {}TSScluster.report'.format(dir_output+'/')
    check_call(command, shell=True)
    os.remove('cluster.report.temp')
    
    print "The output file is {}.".format(os.path.basename(output_file))
    print "The output path is {}.".format(dir_output)
    print "Also generate TSScluster.report having the original TSS in each cluster."
    print 'There are {} TSS clusters in the output file.'.format(display) 
    print 'There are {} reads that are filtered because they are not in the cluster with TPM_summit above {}.'.format(count_filter, cutoff)
    print "=================="
    return 1
    
  
##-------Parser
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', help='input bed', dest='input_file')
    parser.add_argument('-o', '--output', help='output file name', dest='output_file')
    parser.add_argument('-d', '--distance', help='distance for adjacent TSS', type=int, dest='distance', default=5)
    parser.add_argument('-c', '--cutoff', help='cutoff of TPM', type=float, dest='cutoff', default=0)
        
    args = parser.parse_args()
    cluster_TSS(args.input_file, args.output_file, args.distance, args.cutoff)

    
 