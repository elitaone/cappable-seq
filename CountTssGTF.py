#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
# author Bo Yan

'''
# Logs:

Created on Sept 4, 2018

Made modification on Feb 4,2019: 
    change to generate temporary dir based on the current time instead of tempSuffix (therefore remove --sufix), 
    so multiple threads can run this script in parallel without conflicts. 
'''

'''
Based on python 2.7

This is used to count the TPM or nio of each TSS.

Usage:
$python CountTssGTF.py --input .gtf --output tsscount.gtf --cutoff (default 0)

Logic:
For each position in the genome, the algorithm counts the number of Tss tags in each orientation (nio);
output coordination is 1-based.
Since the Tss position is based on the bed file which is converted from the bam file, 
whether using soft clip or not during the mapping is important for the Tss caculation.

--input: a gtf file having the read information, which is generated from bam or bed using bam2gtf.py.
         e.g.
         NC_000913.3     Replicate1_enriched.bam gtf     1       87      .       +       1-coordination  M01193:350:000000000-AAM45:1:1108:18550:9187;44

--output: a sorted standard gtf tss file correponding to TSS genomic position. The coordinates are also in 1-based system.
        e.g.
        chr, source, feature, TSS, TSS, TPM, strand, coordination, attribute (nio=number of reads; TPM)
        NC_000913.3     Replicate1_enriched.gtf tssgtf  12      12      0.15128805897   +       1-coordination  nio=2;TPM=0.15128805897;
        NC_000913.3     Replicate1_enriched.gtf tssgtf  27      27      0.453864176909  +       1-coordination  nio=6;TPM=0.453864176909;
        Here soure is the input file name.
        For the attribute, I add ';' at the end, which is used for re.findall search in the other functions.

--cutoff: a float used to filter out positions whose TPM are below the defined cutoff (default 0, no filtering)

Note:
(1) This script could be used for genome with multiple chrs.
(2) This script equals to CoungTSSBED.py + tss2gtf.py, but it generates gtf file as output and take gtf file as input.
(3) This script requires bedtools, so need bedtools in $PATH or change the bedtools path manually in the parser.
(4) Result is the same as generated by Laurence's bam2firstbasegtf.pl;
    nio: number of reads starting at this TSS positions;
    TPM = nio/(total number of entries in the bed file converted by bamtobed)*1,000,000
(5) output has the precise TSS information that could be used for getfasta directly to have the nucleotide at the TSS position:
    $bedtools getfasta -s -fi /mnt/home/ettwiller/yan/reference/GRC38_hg20/ensembl/Homo_sapiens.GRCh38.dna.primary_assembly.fa -bed .gtf -fo temp.fasta
    >1:15425884-15425885(+) = IGV 15425885
    G
(6) The output gtf is sorted based on the chr and start (sort -f -k1,1 -k4,4n).
'''

try:
    import os
    import re
    import argparse
    from subprocess import check_call, check_output
    import time
except:
    print "Module Error!"
    quit()

##-------functions

def firstbase(input_gtf):
    '''
    Use to create a gtf file TSS;
    input split.1
    output split.1.onebase
    '''
    output = open(input_gtf+'.onebase','w')
    with open(input_gtf) as f:
        for line in f:
            line = line.strip().split('\t')
            if line[6] =="+":
                line[4] = line[3]
            else:
                line[3] = line[4]
            print>>output, "\t".join(line)
    output.close()
        
        
def main_countreads(input_gtf, output_gtf, cutoff, path):
    '''
    path is the path of bedtools
    type is bam or bed
    
    For each position in the genome, the alorithm counts the number of Tss tags in each orientation;
    input is a bam file, 
    I do not do any filter of the bam reads here, therefore pre filter (e.g. -f 4, -f 256) before this counting step.
    output is a gtf file, e.g.
    chr, source, feature, TSS, TSS, TPM, strand, coordination, attribute (nio=number of reads; TPM)
    NC_000913.3     M9.adjust.bed   tssgtf  143     143     2.66445339405   +       1-coordination  nio=2;TPM=2.66445339405;
    
    Note:
    TPM = nio/(total number of entries in the bed file converted by bamtobed)*1000000.
    '''
    print "============="
    localtime = time.asctime(time.localtime()) # return e.g. Mon Feb  4 15:33:23 2019
    
    print "Start at:", localtime
    print "Counting the number of TSS tags for input file {}.".format(os.path.basename(input_gtf))
    
    feature = 'tssgtf'
    source = os.path.basename(input_gtf)
    
    dir = os.getcwd() # current working dir
    
    # create temporary dir to save the temporary files, which based on local time, so it will not be the same for different threads
    suffix = localtime.split()[-2].split(':')
    suffix.append(localtime.split()[-1]) 
    suffix= ''.join(suffix) # 1533232019
    print "Creating temporary dir {}".format('temp' + suffix)
    
    try:
        os.mkdir('temp'+suffix)
    except:
        print "Temporary dir exists!"
        quit()

    command = 'cp {} {}'.format(input_gtf, 'temp' + suffix +'/count.temp.gtf')
    check_call(command, shell = True)
    os.chdir('temp'+suffix)
    command = 'wc -l count.temp.gtf'
    totalnumber = int(check_output(command, shell = True).split()[0])
        
    print "There are %d number of reads used for caculating Tss tags." % totalnumber
    
       
    ## split based on chr, output files: split.chr1, split.chr2..., split.chr1.KI270724.1.. for human genome
    command = "awk -F \'\\t' \'{print > $1}\' count.temp.gtf"   
    check_call(command, shell = True)
    
    # Note: if chr column contains '|', e.g. Ecoli gi|556503834|ref|NC_000913.3|, it will cause error when running linux command
    # e.g. split.gi|556503834|ref|NC_000913.3| is renamed as split.gi_556503834_ref_NC_000913.3_ for the following steps
    
    for item in os.listdir(os.getcwd()): # item is the filename without path
        if item != 'count.temp.gtf':
            new_name = 'split.' + re.sub('[\|\&]', '_', item) 
            os.rename(item, new_name)
    # e.g. split.NC_000913.3
    
    ## sort and count uniq
    for file in os.listdir(os.getcwd()):
        if 'split' in os.path.basename(file):
            firstbase(file) # split.NC_000913.3.onebase
            command = 'cut -f1-5,7 ' + file + '.onebase' + '|sort -k4,4n -k6|uniq -c' + '>' + file + '.uniqc' # split.NC_000913.3.uniqc
            # Note: uniq -c is based on the entire line, so the same (start,end) but on different strands are different entries
            check_call(command, shell = True)
    
    # split.NC_000913.3.uniqc
    #    2 NC_000913.3        M9.adjust.bed   gtf     143     143     +       
    output=open(os.path.basename(output_gtf),'w')
    totalTpm = 0
    totalTss = 0
    for file in os.listdir(os.getcwd()):
        if 'uniqc' in os.path.basename(file):
            with open(file) as f:
                for line in f:
                    totalTss +=1
                    list = [line.strip().split()[1], source, feature] 
                    list.extend(line.strip().split()[4:6])
                    TPM = int(line.strip().split()[0])*1000000.0/totalnumber
                    list.append(str(TPM))
                    list.append(line.strip().split()[6]) # strand
                    list.append('1-coordination')
                    temp = ";".join(['nio=' + line.strip().split()[0], 'TPM='+str(TPM),'']) # I add '' here to have the ';' at the end of '\t'.join(list)
                    list.append(temp)
                    if TPM>=cutoff:
                        print>>output, '\t'.join(list)
                        totalTpm +=1
                         
    print "There are %d unique TSS tags in the output file." % totalTss
    print "Among these unique TSS tags, there are %d having TPM above %f." % (totalTpm, cutoff)
    output.close()
    
    # sort the output file and move it to the required dir
    if os.path.dirname(output_gtf): # e.g. --output /mnt/home/ettwiller/yan/Ira_CappableSeq/analysisfile/Replicate1_enrich.gtf
        command = 'sort -k1,1 -k4,4n ' + os.path.basename(output_gtf) + '>' + os.path.abspath(output_gtf)
        dir_output = os.path.dirname(output_gtf)
        if dir_output == '.': # e.g. --output ./Replicate1_enrich.gtf
            dir_output = dir
    else: # e.g. --output Replicate1_enrich.tss
        command = 'sort -k1,1 -k4,4n ' + os.path.basename(output_gtf) + '> ../' + os.path.basename(output_gtf)
        dir_output = dir

    check_call(command, shell = True)
    
    print "The output file is {}.".format(os.path.basename(output_gtf))
    print "The output path is {}.".format(dir_output) # e.g. /mnt/home/ettwiller/yan/Ira_CappableSeq/TSS

    os.chdir(dir)
    command = 'rm -r ' + ' temp' + suffix
    check_call(command, shell = True)

    localtime = time.asctime(time.localtime())
    print "End at :", localtime
    print "============="
    return 1

    
##-------Parser
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', help='input file name', dest='input_file')
    parser.add_argument('-o', '--output', help='output file name', dest='output_file')
    parser.add_argument('-c', '--cutoff', help='cutoff of TPM', type=float, dest='cutoff', default=0)

    args = parser.parse_args()

    # bedtools path
    #path = '/home/yan/bin/' # this is the path on server for bedtools
    path = '' # if bedtools is added into PATH
    main_countreads(args.input_file, args.output_file, args.cutoff, path)
   
    
 
